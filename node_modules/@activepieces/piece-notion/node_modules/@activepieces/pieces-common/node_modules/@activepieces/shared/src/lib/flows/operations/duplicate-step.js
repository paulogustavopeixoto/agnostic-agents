"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports._duplicateStep = _duplicateStep;
exports._duplicateBranch = _duplicateBranch;
const common_1 = require("../../common");
const action_1 = require("../actions/action");
const flow_structure_util_1 = require("../util/flow-structure-util");
const import_flow_1 = require("./import-flow");
const _1 = require(".");
function findUnusedName(existingNames, prefix) {
    let index = 1;
    let name = `${prefix}_${index}`;
    while (existingNames.includes(name)) {
        index++;
        name = `${prefix}_${index}`;
    }
    return name;
}
function mapToNewNames(flowVersion, clonedAction) {
    const existingNames = flow_structure_util_1.flowStructureUtil.getAllSteps(flowVersion.trigger)
        .map(step => step.name);
    const oldStepNames = flow_structure_util_1.flowStructureUtil.getAllSteps(clonedAction)
        .map(step => step.name);
    return oldStepNames.reduce((nameMap, oldName) => {
        const newName = findUnusedName(existingNames, 'step');
        existingNames.push(newName);
        return Object.assign(Object.assign({}, nameMap), { [oldName]: newName });
    }, {});
}
function replaceOldStepNameWithNewOne({ input, oldStepName, newStepName, }) {
    const regex = /{{(.*?)}}/g; // Regular expression to match strings inside {{ }}
    return input.replace(regex, (match, content) => {
        // Replace the content inside {{ }} using the provided function
        const replacedContent = content.replaceAll(new RegExp(`\\b${oldStepName}\\b`, 'g'), `${newStepName}`);
        // Reconstruct the {{ }} with the replaced content
        return `{{${replacedContent}}}`;
    });
}
function clone(step, oldNameToNewName) {
    step.displayName = `${step.displayName} Copy`;
    step.name = oldNameToNewName[step.name];
    if ('input' in step.settings) {
        Object.keys(oldNameToNewName).forEach((oldName) => {
            const settings = step.settings;
            settings.input = (0, common_1.applyFunctionToValuesSync)(settings.input, (value) => {
                if ((0, common_1.isString)(value)) {
                    return replaceOldStepNameWithNewOne({
                        input: value,
                        oldStepName: oldName,
                        newStepName: oldNameToNewName[oldName],
                    });
                }
                return value;
            });
        });
    }
    if (step.settings.inputUiInfo) {
        step.settings.inputUiInfo.currentSelectedData = undefined;
        step.settings.inputUiInfo.sampleDataFileId = undefined;
        step.settings.inputUiInfo.lastTestDate = undefined;
    }
    return step;
}
function _duplicateStep(stepName, flowVersion) {
    const clonedAction = JSON.parse(JSON.stringify(flow_structure_util_1.flowStructureUtil.getActionOrThrow(stepName, flowVersion.trigger)));
    const clonedActionWithoutNextAction = Object.assign(Object.assign({}, clonedAction), { nextAction: undefined });
    const oldNameToNewName = mapToNewNames(flowVersion, clonedActionWithoutNextAction);
    const clonedSubflow = flow_structure_util_1.flowStructureUtil.transferStep(clonedActionWithoutNextAction, (step) => {
        return clone(step, oldNameToNewName);
    });
    const importOperations = (0, import_flow_1._getImportOperations)(clonedSubflow);
    return [
        {
            type: _1.FlowOperationType.ADD_ACTION,
            request: {
                action: clonedSubflow,
                parentStep: stepName,
                stepLocationRelativeToParent: _1.StepLocationRelativeToParent.AFTER,
            },
        },
        ...importOperations,
    ];
}
function _duplicateBranch(routerName, childIndex, flowVersion) {
    const router = flow_structure_util_1.flowStructureUtil.getActionOrThrow(routerName, flowVersion.trigger);
    const clonedRouter = JSON.parse(JSON.stringify(router));
    const operations = [{
            type: _1.FlowOperationType.ADD_BRANCH,
            request: {
                branchName: `${clonedRouter.settings.branches[childIndex].branchName} Copy`,
                branchIndex: childIndex + 1,
                stepName: routerName,
                conditions: clonedRouter.settings.branches[childIndex].branchType === action_1.BranchExecutionType.CONDITION ? clonedRouter.settings.branches[childIndex].conditions : undefined,
            },
        }];
    const childRouter = clonedRouter.children[childIndex];
    if (!(0, common_1.isNil)(childRouter)) {
        const oldNameToNewName = mapToNewNames(flowVersion, childRouter);
        const clonedSubflow = flow_structure_util_1.flowStructureUtil.transferStep(childRouter, (step) => {
            return clone(step, oldNameToNewName);
        });
        const importOperations = (0, import_flow_1._getImportOperations)(clonedSubflow);
        operations.push({
            type: _1.FlowOperationType.ADD_ACTION,
            request: {
                stepLocationRelativeToParent: _1.StepLocationRelativeToParent.INSIDE_BRANCH,
                action: clonedSubflow,
                parentStep: routerName,
                branchIndex: childIndex + 1,
            },
        });
        operations.push(...importOperations);
    }
    return operations;
}
//# sourceMappingURL=duplicate-step.js.map