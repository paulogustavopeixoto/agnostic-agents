"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.anthropic = void 0;
const tslib_1 = require("tslib");
const sdk_1 = tslib_1.__importDefault(require("@anthropic-ai/sdk"));
const __1 = require("../..");
const mime_types_1 = tslib_1.__importDefault(require("mime-types"));
const anthropic = ({ proxyUrl, engineToken }) => {
    const sdk = new sdk_1.default({
        apiKey: engineToken,
        baseURL: proxyUrl,
        defaultHeaders: {
            Authorization: `Bearer ${engineToken}`,
        },
    });
    return {
        provider: 'ANTHROPIC',
        function: {
            call: (params) => tslib_1.__awaiter(void 0, void 0, void 0, function* () {
                var _a;
                const messages = params.messages.map((message) => ({
                    role: 'user',
                    content: [
                        { type: 'text', text: message.content },
                    ],
                }));
                if (params.image) {
                    messages.push({
                        role: 'user',
                        content: [
                            {
                                type: 'image',
                                source: {
                                    type: 'base64',
                                    media_type: (params.image.extension &&
                                        mime_types_1.default.lookup(params.image.extension)) || 'image/jpeg',
                                    data: params.image.base64,
                                },
                            },
                        ],
                    });
                }
                const completion = yield sdk.messages.create({
                    model: params.model,
                    messages: messages,
                    max_tokens: (_a = params.maxTokens) !== null && _a !== void 0 ? _a : 2000,
                    tools: params.functions.map((functionDefinition) => ({
                        name: functionDefinition.name,
                        description: functionDefinition.description,
                        input_schema: functionDefinition.arguments,
                    })),
                    tool_choice: { type: 'tool', name: params.functions[0].name },
                });
                const toolCallsResponse = completion.content.filter((choice) => choice.type === 'tool_use');
                const toolCall = toolCallsResponse[0];
                return {
                    choices: completion.content
                        .filter((choice) => choice.type === 'text')
                        .map((choice) => ({
                        content: choice.text,
                        role: __1.AIChatRole.ASSISTANT,
                    })),
                    call: toolCall
                        ? {
                            id: toolCall.id,
                            function: {
                                name: toolCall.name,
                                arguments: toolCall.input,
                            },
                        }
                        : null,
                    model: completion.model,
                    created: new Date().getTime(),
                    usage: {
                        completionTokens: completion.usage.output_tokens,
                        promptTokens: completion.usage.input_tokens,
                        totalTokens: completion.usage.output_tokens + completion.usage.input_tokens,
                    },
                };
            }),
        },
        chat: {
            text: (params) => tslib_1.__awaiter(void 0, void 0, void 0, function* () {
                var _a, _b;
                const concatenatedSystemMessage = params.messages
                    .filter((message) => message.role === 'system')
                    .map((message) => message.content)
                    .join('\n');
                const completion = yield sdk.messages.create({
                    model: params.model,
                    messages: params.messages.map((message) => ({
                        role: message.role === 'user' ? 'user' : 'assistant',
                        content: message.content,
                    })),
                    temperature: Math.tanh((_a = params.creativity) !== null && _a !== void 0 ? _a : 100),
                    stop_sequences: params.stop,
                    system: concatenatedSystemMessage,
                    stream: false,
                    max_tokens: (_b = params.maxTokens) !== null && _b !== void 0 ? _b : 2000,
                });
                return {
                    choices: completion.content
                        .filter((choice) => choice.type === 'text')
                        .map((choice) => ({
                        content: choice.text,
                        role: __1.AIChatRole.ASSISTANT,
                    })),
                    created: new Date().getTime(),
                    model: completion.model,
                    usage: {
                        completionTokens: completion.usage.output_tokens,
                        promptTokens: completion.usage.input_tokens,
                        totalTokens: completion.usage.output_tokens + completion.usage.input_tokens,
                    },
                };
            })
        },
        image: {
            generate: (parmas) => tslib_1.__awaiter(void 0, void 0, void 0, function* () { return null; }),
        },
    };
};
exports.anthropic = anthropic;
//# sourceMappingURL=index.js.map