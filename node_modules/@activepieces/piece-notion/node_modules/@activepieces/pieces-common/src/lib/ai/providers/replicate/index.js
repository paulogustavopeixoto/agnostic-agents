"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.replicateModels = exports.replicate = void 0;
const tslib_1 = require("tslib");
const pieces_framework_1 = require("@activepieces/pieces-framework");
const shared_1 = require("@activepieces/shared");
const replicate_1 = tslib_1.__importDefault(require("replicate"));
const __1 = require("../..");
const utils_1 = require("../utils");
const replicate = ({ proxyUrl, engineToken }) => {
    const sdk = new replicate_1.default({
        auth: engineToken,
        baseUrl: `${proxyUrl}/v1`,
    });
    return {
        provider: 'replicate',
        image: {
            generate: (params) => tslib_1.__awaiter(void 0, void 0, void 0, function* () {
                const mapper = findMapper(params.model, utils_1.ModelType.IMAGE);
                const modelOwner = params.model.split('/')[0];
                const modelName = params.model.split('/')[1];
                const versionId = params.model.split(':')[1];
                const prediction = yield sdk.predictions.create({
                    model: `${modelOwner}/${modelName}`,
                    version: versionId,
                    input: yield mapper.encodeInput(params),
                });
                const result = yield sdk.wait(prediction, { interval: 500, mode: "poll" });
                return mapper.decodeOutput(result.output);
            }),
        },
        chat: {
            text: (params) => tslib_1.__awaiter(void 0, void 0, void 0, function* () {
                const mapper = findMapper(params.model, utils_1.ModelType.CHAT);
                const modelOwner = params.model.split('/')[0];
                const modelName = params.model.split('/')[1];
                const versionId = params.model.split(':')[1];
                const prediction = yield sdk.predictions.create({
                    model: `${modelOwner}/${modelName}`,
                    version: versionId,
                    input: yield mapper.encodeInput(params),
                });
                const result = yield sdk.wait(prediction, { interval: 500, mode: "poll" });
                return mapper.decodeOutput(result.output);
            }),
        },
    };
};
exports.replicate = replicate;
const commonImageMapper = (0, utils_1.imageMapper)({
    encodeInput: (params) => tslib_1.__awaiter(void 0, void 0, void 0, function* () {
        var _a, _b, _c, _d;
        const [width, height] = (_b = (_a = params.size) === null || _a === void 0 ? void 0 : _a.split('x').map(Number)) !== null && _b !== void 0 ? _b : [512, 512];
        const negativePrompt = (_d = (_c = params.advancedOptions) === null || _c === void 0 ? void 0 : _c['negativePrompt']) !== null && _d !== void 0 ? _d : null;
        return {
            prompt: params.prompt,
            negative_prompt: negativePrompt,
            width,
            height,
            num_outputs: 1,
        };
    }),
    decodeOutput: (output) => tslib_1.__awaiter(void 0, void 0, void 0, function* () {
        const imageUrls = output;
        const imageUrl = imageUrls[0];
        const image = yield fetch(imageUrl);
        const imageBuffer = yield image.arrayBuffer();
        const imageBase64 = Buffer.from(imageBuffer).toString('base64');
        return {
            image: imageBase64,
        };
    }),
    advancedOptions: {
        negativePrompt: pieces_framework_1.Property.ShortText({
            displayName: 'Negative Prompt',
            required: true,
            description: 'A prompt to avoid in the generated image.',
        }),
    }
});
const llamaMapper = (0, utils_1.chatMapper)({
    encodeInput: (params) => tslib_1.__awaiter(void 0, void 0, void 0, function* () {
        var _a;
        const concatenatedSystemMessage = params.messages
            .filter((message) => message.role === __1.AIChatRole.SYSTEM)
            .map((message) => message.content)
            .join('\n');
        return {
            system_prompt: concatenatedSystemMessage,
            temperature: Math.tanh((_a = params.creativity) !== null && _a !== void 0 ? _a : 100),
            prompt: params.messages
                .filter((message) => message.role !== __1.AIChatRole.SYSTEM)
                .map((message) => `${message.role}: ${message.content}`)
                .join('\n'),
            stop_sequences: params.stop,
            max_tokens: params.maxTokens,
        };
    }),
    decodeOutput: (output) => tslib_1.__awaiter(void 0, void 0, void 0, function* () {
        const choices = output;
        return {
            choices: [{
                    content: choices.join(""),
                    role: __1.AIChatRole.ASSISTANT,
                }],
        };
    }),
});
const mistralMapper = (0, utils_1.chatMapper)({
    encodeInput: (params) => tslib_1.__awaiter(void 0, void 0, void 0, function* () {
        var _a;
        const concatenatedSystemMessage = params.messages
            .filter((message) => message.role === __1.AIChatRole.SYSTEM)
            .map((message) => message.content)
            .join('\n');
        return {
            system_prompt: concatenatedSystemMessage,
            temperature: Math.tanh((_a = params.creativity) !== null && _a !== void 0 ? _a : 100),
            prompt: params.messages
                .filter((message) => message.role !== __1.AIChatRole.SYSTEM)
                .map((message) => `${message.role}: ${message.content}`)
                .join('\n'),
            stop_sequences: params.stop,
            max_new_tokens: params.maxTokens,
        };
    }),
    decodeOutput: (output) => tslib_1.__awaiter(void 0, void 0, void 0, function* () {
        const choices = output;
        return {
            choices: [{
                    content: choices.join(""),
                    role: __1.AIChatRole.ASSISTANT,
                }],
        };
    }),
});
exports.replicateModels = [
    (0, utils_1.model)({
        label: "meta/meta-llama-3-70b-instruct",
        value: "meta/meta-llama-3-70b-instruct",
        supported: ['text']
    }).mapper(llamaMapper),
    (0, utils_1.model)({
        label: "meta/meta-llama-3-8b-instruct",
        value: "meta/meta-llama-3-8b-instruct",
        supported: ['text']
    }).mapper(llamaMapper),
    (0, utils_1.model)({
        label: "mistralai/mixtral-8x7b-instruct-v0.1",
        value: "mistralai/mixtral-8x7b-instruct-v0.1",
        supported: ['text']
    }).mapper(mistralMapper),
    (0, utils_1.model)({
        label: "mistralai/mistral-7b-instruct-v0.2",
        value: "mistralai/mistral-7b-instruct-v0.2",
        supported: ['text']
    }).mapper(mistralMapper),
    (0, utils_1.model)({ label: 'bytedance/sdxl-lightning-4step', value: 'bytedance/sdxl-lightning-4step:5599ed30703defd1d160a25a63321b4dec97101d98b4674bcc56e41f62f35637', supported: ['image'] })
        .mapper(commonImageMapper),
    (0, utils_1.model)({ label: 'stability-ai/stable-diffusion', value: 'stability-ai/stable-diffusion:ac732df83cea7fff18b8472768c88ad041fa750ff7682a21affe81863cbe77e4', supported: ['image'] })
        .mapper(commonImageMapper),
    (0, utils_1.model)({ label: 'black-forest-labs/flux-schnell', value: 'black-forest-labs/flux-schnell', supported: ['image'] })
        .mapper((0, utils_1.imageMapper)({
        advancedOptions: {},
        decodeOutput: commonImageMapper.decodeOutput,
        encodeInput: (params) => tslib_1.__awaiter(void 0, void 0, void 0, function* () {
            const commonParams = yield commonImageMapper.encodeInput(params);
            const width = commonParams.width;
            const height = commonParams.height;
            const gcd = (a, b) => b === 0 ? a : gcd(b, a % b);
            const divisor = gcd(width, height);
            const aspectRatio = `${width / divisor}:${height / divisor}`;
            return Object.assign(Object.assign({}, commonParams), { megapixels: "1", aspect_ratio: aspectRatio, output_format: "png" });
        }),
    })),
];
const findMapper = (model, type) => {
    var _a;
    const mapper = (_a = exports.replicateModels.find(m => m.value === model)) === null || _a === void 0 ? void 0 : _a.mapper;
    if ((0, shared_1.isNil)(mapper) || mapper.__tag !== type) {
        throw new Error(`${type} model ${model} not found`);
    }
    return mapper;
};
//# sourceMappingURL=index.js.map