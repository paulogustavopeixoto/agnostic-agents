"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.getAccessTokenOrThrow = void 0;
exports.createCustomApiCallAction = createCustomApiCallAction;
const tslib_1 = require("tslib");
const pieces_framework_1 = require("@activepieces/pieces-framework");
const http_1 = require("../http");
const shared_1 = require("@activepieces/shared");
const getAccessTokenOrThrow = (auth) => {
    const accessToken = auth === null || auth === void 0 ? void 0 : auth.access_token;
    if (accessToken === undefined) {
        throw new Error('Invalid bearer token');
    }
    return accessToken;
};
exports.getAccessTokenOrThrow = getAccessTokenOrThrow;
function createCustomApiCallAction({ auth, baseUrl, authMapping, description, displayName, name, props, extraProps, }) {
    var _a, _b, _c, _d, _e, _f;
    return (0, pieces_framework_1.createAction)({
        name: name ? name : 'custom_api_call',
        displayName: displayName ? displayName : 'Custom API Call',
        description: description
            ? description
            : 'Make a custom API call to a specific endpoint',
        auth: auth ? auth : undefined,
        requireAuth: auth ? true : false,
        props: Object.assign({ url: pieces_framework_1.Property.DynamicProperties({
                displayName: '',
                required: true,
                refreshers: [],
                props: (_a) => tslib_1.__awaiter(this, [_a], void 0, function* ({ auth }) {
                    var _b;
                    return {
                        url: pieces_framework_1.Property.ShortText(Object.assign({ displayName: 'URL', description: 'The full URL to use, including the base URL', required: true, defaultValue: baseUrl(auth) }, ((_b = props === null || props === void 0 ? void 0 : props.url) !== null && _b !== void 0 ? _b : {}))),
                    };
                }),
            }), method: pieces_framework_1.Property.StaticDropdown(Object.assign({ displayName: 'Method', required: true, options: {
                    options: Object.values(http_1.HttpMethod).map((v) => {
                        return {
                            label: v,
                            value: v,
                        };
                    }),
                } }, ((_a = props === null || props === void 0 ? void 0 : props.method) !== null && _a !== void 0 ? _a : {}))), headers: pieces_framework_1.Property.Object(Object.assign({ displayName: 'Headers', description: 'Authorization headers are injected automatically from your connection.', required: true }, ((_b = props === null || props === void 0 ? void 0 : props.headers) !== null && _b !== void 0 ? _b : {}))), queryParams: pieces_framework_1.Property.Object(Object.assign({ displayName: 'Query Parameters', required: true }, ((_c = props === null || props === void 0 ? void 0 : props.queryParams) !== null && _c !== void 0 ? _c : {}))), body: pieces_framework_1.Property.Json(Object.assign({ displayName: 'Body', required: false }, ((_d = props === null || props === void 0 ? void 0 : props.body) !== null && _d !== void 0 ? _d : {}))), failsafe: pieces_framework_1.Property.Checkbox(Object.assign({ displayName: 'No Error on Failure', required: false }, ((_e = props === null || props === void 0 ? void 0 : props.failsafe) !== null && _e !== void 0 ? _e : {}))), timeout: pieces_framework_1.Property.Number(Object.assign({ displayName: 'Timeout (in seconds)', required: false }, ((_f = props === null || props === void 0 ? void 0 : props.timeout) !== null && _f !== void 0 ? _f : {}))) }, extraProps),
        run: (context) => tslib_1.__awaiter(this, void 0, void 0, function* () {
            const { method, url, headers, queryParams, body, failsafe, timeout } = context.propsValue;
            (0, shared_1.assertNotNullOrUndefined)(method, 'Method');
            (0, shared_1.assertNotNullOrUndefined)(url, 'URL');
            let headersValue = headers;
            if (authMapping) {
                const headers = yield authMapping(context.auth, context.propsValue);
                if (headers) {
                    headersValue = Object.assign(Object.assign({}, headersValue), headers);
                }
            }
            const request = {
                method,
                url: url['url'],
                headers: headersValue,
                queryParams: queryParams,
                timeout: timeout ? timeout * 1000 : 0,
            };
            if (body) {
                request.body = body;
            }
            try {
                return yield http_1.httpClient.sendRequest(request);
            }
            catch (error) {
                if (failsafe) {
                    return error.errorMessage();
                }
                throw error;
            }
        }),
    });
}
//# sourceMappingURL=index.js.map