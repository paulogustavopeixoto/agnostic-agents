"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.githubCommon = void 0;
exports.githubApiCall = githubApiCall;
exports.githubPaginatedApiCall = githubPaginatedApiCall;
const tslib_1 = require("tslib");
const pieces_common_1 = require("@activepieces/pieces-common");
const pieces_framework_1 = require("@activepieces/pieces-framework");
const shared_1 = require("@activepieces/shared");
exports.githubCommon = {
    baseUrl: 'https://api.github.com',
    repositoryDropdown: pieces_framework_1.Property.Dropdown({
        displayName: 'Repository',
        refreshers: [],
        required: true,
        options: (_a) => tslib_1.__awaiter(void 0, [_a], void 0, function* ({ auth }) {
            if (!auth) {
                return {
                    disabled: true,
                    options: [],
                    placeholder: 'please authenticate first',
                };
            }
            const authProp = auth;
            const repositories = yield getUserRepo(authProp);
            return {
                disabled: false,
                options: repositories.map((repo) => {
                    return {
                        label: repo.owner.login + '/' + repo.name,
                        value: {
                            owner: repo.owner.login,
                            repo: repo.name,
                        },
                    };
                }),
            };
        }),
    }),
    assigneeDropDown: (required = false) => pieces_framework_1.Property.MultiSelectDropdown({
        displayName: 'Assignees',
        description: 'Assignees for the Issue',
        refreshers: ['repository'],
        required,
        options: (_a) => tslib_1.__awaiter(void 0, [_a], void 0, function* ({ auth, repository }) {
            if (!auth || !repository) {
                return {
                    disabled: true,
                    options: [],
                    placeholder: 'please authenticate first and select repo',
                };
            }
            const authProp = auth;
            const { owner, repo } = repository;
            const assignees = yield getAssignee(authProp, owner, repo);
            return {
                disabled: false,
                options: assignees.map((assignee) => {
                    return {
                        label: assignee.login,
                        value: assignee.login,
                    };
                }),
            };
        }),
    }),
    labelDropDown: (required = false) => pieces_framework_1.Property.MultiSelectDropdown({
        displayName: 'Labels',
        description: 'Labels for the Issue',
        refreshers: ['repository'],
        required,
        options: (_a) => tslib_1.__awaiter(void 0, [_a], void 0, function* ({ auth, repository }) {
            if (!auth || !repository) {
                return {
                    disabled: true,
                    options: [],
                    placeholder: 'please authenticate first and select repo',
                };
            }
            const authProp = auth;
            const { owner, repo } = repository;
            const labels = yield listIssueLabels(authProp, owner, repo);
            return {
                disabled: false,
                options: labels.map((label) => {
                    return {
                        label: label.name,
                        value: label.name,
                    };
                }),
            };
        }),
    }),
};
function getUserRepo(authProp) {
    return tslib_1.__awaiter(this, void 0, void 0, function* () {
        const response = yield githubPaginatedApiCall({
            accessToken: authProp.access_token,
            method: pieces_common_1.HttpMethod.GET,
            resourceUri: '/user/repos',
        });
        return response;
    });
}
function getAssignee(authProp, owner, repo) {
    return tslib_1.__awaiter(this, void 0, void 0, function* () {
        const response = yield githubPaginatedApiCall({
            accessToken: authProp.access_token,
            method: pieces_common_1.HttpMethod.GET,
            resourceUri: `/repos/${owner}/${repo}/assignees`,
        });
        return response;
    });
}
function listIssueLabels(authProp, owner, repo) {
    return tslib_1.__awaiter(this, void 0, void 0, function* () {
        const response = yield githubPaginatedApiCall({
            accessToken: authProp.access_token,
            method: pieces_common_1.HttpMethod.GET,
            resourceUri: `/repos/${owner}/${repo}/labels`,
        });
        return response;
    });
}
function githubApiCall(_a) {
    return tslib_1.__awaiter(this, arguments, void 0, function* ({ accessToken, method, resourceUri, query, body, }) {
        const baseUrl = 'https://api.github.com';
        const qs = {};
        if (query) {
            for (const [key, value] of Object.entries(query)) {
                if (value !== null && value !== undefined) {
                    qs[key] = String(value);
                }
            }
        }
        const request = {
            method,
            url: baseUrl + resourceUri,
            authentication: {
                type: pieces_common_1.AuthenticationType.BEARER_TOKEN,
                token: accessToken,
            },
            queryParams: qs,
            body,
        };
        const response = yield pieces_common_1.httpClient.sendRequest(request);
        return response;
    });
}
function githubPaginatedApiCall(_a) {
    return tslib_1.__awaiter(this, arguments, void 0, function* ({ accessToken, method, resourceUri, query, body, }) {
        var _b;
        const qs = query ? query : {};
        qs.page = 1;
        qs.per_page = 100;
        const resultData = [];
        let hasMoreItems = true;
        do {
            const response = yield githubApiCall({
                accessToken,
                method,
                resourceUri,
                query: qs,
                body,
            });
            qs.page = qs.page + 1;
            resultData.push(...response.body);
            const linkHeader = (_b = response.headers) === null || _b === void 0 ? void 0 : _b.link;
            hasMoreItems = !(0, shared_1.isNil)(linkHeader) && linkHeader.includes(`rel="next"`);
        } while (hasMoreItems);
        return resultData;
    });
}
//# sourceMappingURL=index.js.map