"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.mcpToolNaming = exports.McpToolMetadata = exports.McpWithTools = exports.Mcp = void 0;
const typebox_1 = require("@sinclair/typebox");
const common_1 = require("../common");
const id_generator_1 = require("../common/id-generator");
const mcp_tool_1 = require("./tools/mcp-tool");
exports.Mcp = typebox_1.Type.Object(Object.assign(Object.assign({}, common_1.BaseModelSchema), { name: typebox_1.Type.String(), projectId: id_generator_1.ApId, token: id_generator_1.ApId, agentId: typebox_1.Type.Optional(id_generator_1.ApId) }));
exports.McpWithTools = typebox_1.Type.Composite([
    exports.Mcp,
    typebox_1.Type.Object({
        tools: typebox_1.Type.Array(mcp_tool_1.McpTool),
    }),
]);
const MAX_TOOL_NAME_LENGTH = 47;
exports.McpToolMetadata = typebox_1.Type.Object({
    displayName: typebox_1.Type.String(),
    logoUrl: typebox_1.Type.Optional(typebox_1.Type.String()),
});
exports.mcpToolNaming = {
    fixTool: (name, id, type) => {
        const spaceToReserve = id.length + 1;
        const baseName = name.replace(/[\s/@-]+/g, '_');
        switch (type) {
            case mcp_tool_1.McpToolType.FLOW:
                return `${baseName.slice(0, MAX_TOOL_NAME_LENGTH - spaceToReserve)}_${id}`;
            case mcp_tool_1.McpToolType.PIECE: {
                return `${baseName.slice(0, MAX_TOOL_NAME_LENGTH - spaceToReserve)}_${id}`;
            }
        }
    },
    fixProperty: (schemaName) => {
        return schemaName.replace(/[\s/@-]+/g, '_');
    },
    extractToolId: (toolName) => {
        const splitted = toolName.split('_');
        return splitted[splitted.length - 1];
    },
};
//# sourceMappingURL=mcp.js.map